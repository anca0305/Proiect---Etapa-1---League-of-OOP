Andronache Anca-Maria
ACS, CTI, anul 2, grupa 324CD

		Proiect - Etapa 2 - League of OOP

	Buna! Voi incerca sa explic cat de bine pot ce face codul meu. In implementarea temei am ales sa am 4 pachete- common, heroes, main si map.
	Primul pachet - common - contine o singura clasa, denumita Constants - clasa in care voi scrie toate constantele aparute in cod. Acestea au nume sugestive pentru a putea fi usor de folosit.
	Al doilea pachet contine sase clase. Prima clasa, Hero, este clasa abstracta ce va fi mostenita de cele patru clase ce poarta numele tipurilor de eroi. Avem urmatoarele campuri: mainGround - terenul pe care abilitatile jucatorilor vor fi amplificate cu valoarea 1 + bonusDamage, initialhp- hp-ul initial al eroului, hpperlevel- hp-ul pe care il va primi eroul pentru fiecare nivel, raceAmplificationFA si SA- valoarea cu care va fi amplificat damage-ul dat de fiecare abilitate in parte (FA- first ability, SA- secod ability) in functie de tipul eroului pe care il ataca, damage- valoarea cu care va scadea hp-ul adversarului, damageFirstAbility si secondAbility- valorile damage-ului initial dat de abilitatile eroilor, periodicDamage- valoarea damage-ului cu efect prelungit, noRoundsToReceivePeriodicDamage si noRoundsCantMove- valori ce retin numarul de runde in care eroii vor fi sub influenta unei abilitati prelungite date de un alt erou, currentRound- runda curenta, x si y- coordonatele eroului pe harta, hp- viata eroului, xp- experienta lui, level- nivelul eroului, groundAmplification- valoarea cu care va fi amplificat damage-ul in functie de terenul pe care se alfa eroul, dead- starea eroului- in viata sau mort, killer- eroul care l-a omorat pe eroul curent.
	Intrucat metodele sunt comentate, voi explica putin cum am gandit campurile mai sus mentionate. In primul rand, le-am dat nume sugestive. In al doilea rand, valorile de tip procent din cerinta au fost transformate in valori de tip float: 20% => 0.2. Am ales sa adaug acest bonus la valoarea 1 pentru a inmulti direct (nu sub forma: damage = damage + 0.2 * damage, ci sub forma damage *= 1.2).
	Cea de-a doua clasa din acest pachet - HeroesFactory, are rolul de a crea lista de eroi in functie de caracterul citit la intrare.
	Urmatoarele patru clase sunt clase ce mostenesc clasa abstracta Hero, deci ii suprascriu si metodele. Am folosit double dispatch pentru a putea afla raceAmplificationFA si SA indiferent de eroii ce vor participa la lupta. Pentru aceasta, am folosit metoda calculateRaceAmplificationFor ce va ,,accepta" apelurile functiilor calculateRaceAmplification pentru fiecare tip de erou in parte.
	Pachetul main contine trei clasa. Primele doua - GameInput si GameInputLoader folosesc implementarea claselor cu acelasi nume din prima tema. Voi afla astfel lista eroilor (primiti sub forma de caractere si transformati ulterior in eroi), pozitiile acestor eroi, matricea mutarilor, si numarul rundelor. In clasa Main se va desfasura jocul propriu-zis: pentru fiecare runda se vor executa miscarile corespunzatoare, miscari in urma carora se va seta terenul curent al fiecarui erou, iar apoi, pentru eroii aflati pe aceeasi pozitie se va verifica hp-ul (daca este mai mic sau egal cu 0 eroul va fi declarat mort). Daca ambii eroi sunt in viata, acestia isi vor da reciproc damage. Daca primul erou a murit atunci killer-ul lui va primi xp-ul corespunzator si i se va face testul pentru cresterea in nivel. In mod asemanator, daca cel de-al doilea a murit, killer-ul va primi xp si se va aplica asupra lui metoda checkLevel.
	Ultimul pachet - map contine clasa Moves ce va executa toate mutarile dintr-o runda, dar nu inainte de a verifica abilitatile overtime.
	Toate metodele sunt comentate, asa ca mi se pare redundant sa mai intru in detaliile functionalitatiilor lor.



	Acesta a fost continutul primului README. Pentru continuarea proiectului am adaugat un nou pachet – angels, am adaugat noi constante in pachetul common, clasa Constants, am completat clasa Hero, din pachetul heroes, cu noi functionalitati si am completat clasa principala Main, din pachetul cu acelasi nume.
	Pachetul angels contine 13 clase. Prima clasa, Angel, este clasa abstracta ce va fi mostenita de cele zece clase ce poarta numele tipurilor de ingeri. Avem urmatoarele campuri: name- numele ingerilor, round- runda in care va aparea ingerul in cauza, x si y- coordonatele pe harta ale locului unde va aparea ingerul, type- tipul ingerului. 
       Ca si in prima etapa, toate metodele sunt comentate, iar modificatorii vor pastra regula transformarii din procente intr-un numar de tip float. 
	Cea de-a doua clasa din acest pachet - AngelsFactory, are rolul de a crea lista de ingeri in functie de sirul de caractere citit la intrare.
Tipul ingerilor este de tip intreg si poate lua valori intre 1 si 4 (1- ingerul ajuta eroul- ii creste modificatorii de damage si/sau hp-ul, 2- ingerul ,,incurca” eroul- ii scade aceleasi proprietati, 3- ingerul readuce la viata un erou si ii ofera un hp nou, 4- ingerul omoara eroul aflat in acea pozitie).
	Clasa CheckForAngels are o functie ce determina daca un inger si un erou se afla pe aceeasi pozitie pe harta si, daca da,ingerul isi executa actiunile.
	Urmatoarele zece clase sunt clase ce mostenesc clasa abstracta Angel, deci ii suprascriu si metodele. Am folosit double dispatch pentru a putea executa actiunile ingerilor asupra eroilor indiferent de tipul ingerului sau al eroului. Pentru aceasta, am folosit metodele accept si interactWith.
	In pachetul heroes, clasa Hero, am adaugat 4 proprietati: id- id-ul unui erou, name- numele acestuia, checked- valoarea de adevar a proprietatii de a fi primit modificarile date de un inger si oldLevel- nivelul la care se afla inainte de a trece la un alt nivel.
	In pachetul main, clasa Main, am adaugat verificarea pozitiei ingerilor din runda curenta cu cea a eroilor si aplicarea actiunilor corespunzatoare.
	Am continuat incarcarea temei in repository-ul specificat in prima parte a proiectului. Arhiva contine si fisierul .git, iar link-ul catre repository-ul folosit este://github.com/anca0305/Proiect---Etapa-1---League-of-OOP.git.
	In ceea ce priveste checkstyle-ul, am 21 de erori, din care 5 pentru depasirea numarului de 7 parametrii ai unei functii si restul pentru folosirea stelutei la import. Am incercat sa modific, dar IntelliJ-ul imi autocorecteaza. Local primesc -0 checkstyle errors, dar m-am gandit ca ar fi bine sa precizez si in README.
 
	Aceasta este implementarea pe care am gandit-o eu. Sper ca va fi usor de parcurs si inteles. Multumesc pentru parcurgerea README-ului si bafta la corectat! :)
